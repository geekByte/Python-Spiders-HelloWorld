### 网络爬虫是什么

网络爬虫是一种互联网信息的自动化采集程序，主要作用是代替人工对网络互联网中的数据进行自动采集和整理，以快速地、批量地获取目标数据。

## 正则表达式基础

### 基础1

全局匹配函数使用格式  re.compile(正则表达式).findall(源字符串)

| 字符     | 匹配                                |
| -------- | ----------------------------------- |
| 普通字符 | 正常匹配                            |
| \n       | 匹配换行符                          |
| \t       | 匹配制表符                          |
| \w       | 匹配字母、数字、下划线              |
| \W       | 匹配除字母、数字、下划线            |
| \d       | 匹配十进制数字                      |
| \D       | 匹配除十进制数字                    |
| \s       | 匹配空白字符                        |
| \S       | 匹配除空白字符                      |
| [ab89x]  | 原子表，匹配ab89x中的任意一个字符   |
| [^ab89x] | 原子表，匹配除ab89x中的任意一个字符 |

#### 实例1

```
源字符串："geekbyte"
正则表达式："ek"
匹配结果：ek
-----------------------------------------------
源字符串：'''geek
byte
'''
正则表达式："geek\n"
匹配结果：geek\n
-----------------------------------------------
源字符串："geek1024byte"
正则表达式："\w\d\w\d\d\w"
匹配结果：k1024b
-----------------------------------------------
源字符串："geek1024byte"
正则表达式："\w\d[byte]\w"
匹配结果：24by
-----------------------------------------------
```

### 基础2

| 符号  | 匹配                                                         |
| ----- | ------------------------------------------------------------ |
| .     | 匹配除换行符外任意一个字符                                   |
| ^     | 匹配开始位置                                                 |
| $     | 匹配结束位置                                                 |
| *     | 前一个字符出现0\1\多次                                       |
| ？    | 前一个字符出现0\1次                                          |
| +     | 前一个字符出现1\多次                                         |
| {n}   | 前一个字符出现n次                                            |
| {n,}  | 前一个字符出现至少n次                                        |
| {n,m} | 前一个字符出现至少n次且至多m次                               |
| \|    | 模式选择符 或                                                |
| ()    | 模式单元，通俗来说就是，把你想提取的内容在正则中用小括号括起来 |

#### 实例2:

```
源字符串："geek1024byte"

正则表达式："ek.."
匹配结果：ek10
-----------------------------------------------
正则表达式："^ek..."
匹配结果：None
-----------------------------------------------
正则表达式："geek..."
匹配结果：geek1024
-----------------------------------------------
正则表达式："by..$"
匹配结果：byte
-----------------------------------------------
正则表达式："ge.*"
匹配结果：geek1024byte
-----------------------------------------------
正则表达式："ge+"
匹配结果：gee
-----------------------------------------------
正则表达式："geek?"
匹配结果：geek
-----------------------------------------------
正则表达式："ge{1,2}"
匹配结果：gee
-----------------------------------------------
正则表达式："^geek(1...)"
匹配结果：1024
-----------------------------------------------

```



### 基础3:

* 贪婪模式：尽可能多地匹配
* 懒惰模式：尽可能少地匹配，也称为精准模式

默认是懒惰模式

如果出现以下组合，则代表懒惰模式：

* *?
* +?

#### 实例3

```
源字符串："poytphonyhjskjsa"

正则表达式：'p.*y'
匹配结果：poytphony
为什么？	默认贪婪模式
-----------------------------------------
正则表达式："p.*?y"
匹配结果：['poy','phony']
为什么？	懒惰模式，精准匹配
```

### 基础4

模式修正符：在不改变正则表达式的情况下通过模式修正符使匹配结果发生更改

re.S	让.也可以匹配多行

re.I	  让匹配时忽略大小写

#### 实例4

```
源字符串："Python"

正则表达式："pyt"

匹配方式：re.compile("pyt").findall("Python")
匹配结果：[]

匹配方式：re.compile("pyt",re.I).findall("Python")
匹配结果：Pyt

----------------------------------------------------------------------

源字符串：string = '''Hello World！
My name is 
geekByte!
'''

正则表达式：pat="Hel.*?geekByte!"

匹配方式：re.compile(pat).findall(string)
匹配结果：[]

匹配方式：re.compile(pat,re.S).findall(string)
匹配结果：['Hello World!\nMy name is\ngeekByte!']
```

